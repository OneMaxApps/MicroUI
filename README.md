## MicroUI: Библиотека графического интерфейса пользователя (GUI) для Processing 4

Библиотека MicroUI (версия **2.0.0**) была разработана **Ахмедхановым Исламом** [1] для создания многофункциональных пользовательских интерфейсов в среде Processing [1, 2].

### I. Архитектурный обзор

Фундаментальный принцип работы библиотеки MicroUI заключается в организации всех элементов в **Контейнерах** (`Containers`) [Query example]. Управление этими контейнерами осуществляется посредством паттерна синглтон — **`ContainerManager`** [Query example]. Для начала работы необходимо установить контекст Processing, используя статический метод `MicroUI.setContext(PApplet context)` [2].

### II. Системы расположения (Лайоуты)

Библиотека предоставляет **четыре** встроенные системы расположения, обеспечивающие гибкое размещение компонентов внутри контейнеров:

1.  `GridLayout` (Сетчатое расположение).
2.  `LinearLayout` (Линейное расположение).
3.  `RowLayout` (Расположение по строкам).
4.  `ColumnLayout` (Расположение по столбцам).

### III. Компоненты управления (10 элементов)

MicroUI включает **десять** основных компонентов, каждый из которых обладает специфическими возможностями:

1.  **Button** (`Кнопка`): Является базовым элементом управления, наследуется от `AbstractButton` [3, 4]. Внутри себя компонент содержит `TextView` [3].
2.  **CheckBox** (`Флажок`): Также наследуется от `AbstractButton` [5]. Он используется для управления булевым состоянием (`isChecked`) [6] и позволяет настроить цвет отметки (`markColor`) [6, 7].
3.  **LabeledCheckBox** (`Флажок с меткой`): Это композитный компонент, который объединяет `CheckBox` и `TextView` в одном `Container`, используя при этом `RowLayout` для их совместного размещения [8, 9].
4.  **TextView** (`Поле для отображения текста`): Компонент для вывода текста [10]. Он поддерживает различные режимы **автоматического изменения размера** (`AutoResizeMode`), включая `FULL`, `BIG`, `MIDDLE`, `SMALL` и `TINY` [11, 12].
5.  **TextField** (`Поле ввода`): Компонент, предназначенный для однострочного ввода текста, реализующий интерфейс `KeyPressable` [13]. Он управляет позицией курсора (`Cursor`) и выделением (`Selection`) [14], а также поддерживает горизонтальную прокрутку для длинного текста (`scroll`) [14, 15]. Поддерживает стандартные комбинации клавиш, такие как CTRL+C, CTRL+V, CTRL+X и CTRL+A [16, 17].
6.  **EditText** (`Многострочный редактор текста`): Более сложный компонент для многострочного редактирования, реализующий интерфейсы `Scrollable` и `KeyPressable` [18]. Он включает встроенные вертикальную (`scrollV`) и горизонтальную (`scrollH`) полосы прокрутки [19, 20], а также сложные внутренние классы для управления текстом, курсором и выделением [19, 21-23].
7.  **Slider** (`Ползунок`): Линейный элемент управления диапазоном (`LinearRangeControl`) [24]. Он позволяет изменять значение в зависимости от положения мыши при удержании компонента [25].
8.  **Scroll** (`Полоса прокрутки`): Также является линейным элементом управления диапазоном (`LinearRangeControl`) [26, 27]. Включает перемещаемый ползунок (`thumb`), который реализован как отдельный компонент `Button` [27], и используется для навигации по содержимому.
9.  **Knob** (`Поворотный регулятор`): Элемент управления диапазоном (`RangeControl`), который изменяет значение при вращении мышью [28, 29]. Для визуализации текущего значения использует дугу (arc) [30].
10. **MenuButton** (`Кнопка меню`): Расширяет функциональность стандартной кнопки, позволяя отображать выпадающий список других кнопок или вложенных подменю (`subMenu`) [31, 32]. Компонент реализует интерфейс `Scrollable`, что позволяет прокручивать элементы меню, если их много [31, 33].

### IV. Пример инициализации

Ниже представлен стандартный код для инициализации MicroUI и добавления кнопки в контейнер, использующий сетчатое расположение (`GridLayout`):

```java
void setup() {
 fullScreen(); // Установка полноэкранного режима Processing
 MicroUI.setContext(this); // Установка контекста PApplet для MicroUI [2]
 ContainerManager cm = ContainerManager.getInstance(); // Получение синглтона менеджера контейнеров [Query example]

 // Добавление нового контейнера с идентификатором "id", использующего GridLayout
 cm.add(new Container(new GridLayout(3,3),"id"); 
 
 // Получение контейнера по ID и добавление в него компонента Button 
 // Компонент размещается в ячейке (1,1) с помощью GridLayoutParams
 cm.get("id").addComponent(new Button(), new GridLayoutParams(1,1)); 

}

void draw() {
    // Вызов отрисовки компонентов, управляемых ContainerManager.
}
```